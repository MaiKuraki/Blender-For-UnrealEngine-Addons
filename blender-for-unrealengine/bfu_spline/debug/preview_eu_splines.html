<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Unreal Text to JSON Viewer</title>
  <style>
    body { font-family: monospace; padding: 20px; background: #111; color: #eee; }
    textarea { width: 100%; height: 200px; background: #222; color: #0f0; border: 1px solid #555; padding: 10px; }
    pre { background: #1a1a1a; padding: 10px; margin-top: 10px; white-space: pre-wrap; border: 1px solid #333; }
    button { margin-top: 10px; padding: 10px 20px; font-weight: bold; }
    h2, h3 { margin-top: 30px; }
    details summary {
      cursor: pointer;
      font-size: 1.2em;
      margin: 10px 0;
    }

    details summary:hover {
      color: #0f0;
    }
    .summary-title {
      font-size: 1.2em;
      font-weight: bold;
    }
  </style>
</head>
<body>

  <h2>Text Area (Raw Unreal Export)</h2>
  <textarea id="inputText" placeholder="Paste your Unreal text here..."></textarea><br>
  <button onclick="convert()">Convert</button>

  <details closed>
    <summary><span class="summary-title">Pre-formatted JSON-like Text</span></summary>
    <pre id="outputRaw"></pre>
  </details>

  <details closed>
    <summary><span class="summary-title">Result of JSON.parse()</span></summary>
    <pre id="outputParsed"></pre>
  </details>

  <details open>
    <summary><span class="summary-title">Interpretation (manual summary)</span></summary>
    <pre id="outputSummary"></pre>
  </details>

  <script>

    // 🧩 Step 1: Pre-format Unreal to JSON-like string
    function convertTextToJsonString(line) {
    
      function tryConvertValue(str) {
        const lowered = str.toLowerCase();

        if (lowered === "true") return true;
        if (lowered === "false") return false;
        if (lowered === "none" || lowered === "null") return null;
        if (/^-?\d+(\.\d+)?$/.test(str)) return Number(str);

        return `"${str}"`;
      }

      function parse(text) {
        const result = {};
        let i = 0;

        while (i < text.length) {
          // Read the key
          const keyMatch = /^[A-Za-z0-9_]+/.exec(text.slice(i));
          if (!keyMatch) break;
          const key = keyMatch[0];
          i += key.length;

          // Skip '='
          if (text[i] === '=') i++;
          else break;

          // Read the value
          let value = '';
          if (text[i] === '(') {
            let depth = 0;
            let start = i;
            do {
              if (text[i] === '(') depth++;
              else if (text[i] === ')') depth--;
              i++;
            } while (depth > 0 && i < text.length);
            value = text.slice(start, i);

            // Recursive processing
            if (value.startsWith('((')) {
              // List of dictionaries
              value = value.slice(1, -1); // remove one layer of ()
              const list = [];
              let inner = '';
              let depth = 0;
              for (let j = 0; j < value.length; j++) {
                const c = value[j];
                if (c === '(') depth++;
                if (c === ')') depth--;

                inner += c;

                if (depth === 0 && inner.trim()) {
                  const clean = inner.slice(1, -1); // remove ()
                  list.push(parse(clean));
                  inner = '';
                  if (value[j + 1] === ',') j++;
                }
              }
              result[key] = list;
            } else {
              // Simple dictionary
              const inner = value.slice(1, -1);
              result[key] = parse(inner);
            }
          } else {
            // Simple value
            const valMatch = /^[^,\s)]+/.exec(text.slice(i));
            if (valMatch) {
              value = valMatch[0];

              // Remove quotes if present
              if (value.startsWith('"') && value.endsWith('"')) {
                value = value.slice(1, -1);
              }

              result[key] = tryConvertValue(value);
              i += valMatch[0].length;
            }
          }

          // Skip comma and spaces
          while (text[i] === ',' || text[i] === ' ') i++;
        }

        return result;
      }

      function stringify(obj, indent = 0) {
        const ts = '  '.repeat(indent);
        if (Array.isArray(obj)) {
          const elements = obj.map(e => stringify(e, indent + 1));
          return `[\n${ts}  ${elements.join(`,\n${ts}  `)}\n${ts}]`;
        } else if (typeof obj === 'object') {
          const entries = Object.entries(obj).map(
            ([k, v]) => `${ts}  "${k}": ${stringify(v, indent + 1)}`
          );
          return `{\n${entries.join(',\n')}\n${ts}}`;
        } else {
          return `${obj}`;
        }
      }

      const parsed = parse(line);
      return stringify(parsed, 2);
    }

    function preformatTextToJsonString(rawText) {
      const lines = rawText.trim().split('\n');
      const objects = [];
      let currentBlock = [];
      const ts = '  ';

      for (let line of lines) {
        const trimmed = line.trim();

        if (trimmed.startsWith("Begin Object")) {
          const rest = line.replace("Begin Object", "").trim();
          currentBlock = [rest];
        } else if (trimmed.startsWith("End Object")) {
          const fullText = currentBlock.join(' ').trim();
          const converted = convertTextToJsonString(fullText);
          const wrapped = `${ts}${ts}${ts}${converted}\n${ts}${ts}`;
          objects.push(wrapped);
          currentBlock = [];
        } else {
          currentBlock.push(trimmed);
        }
      }

      const start = `{\n${ts}"objects": [\n`;
      const end = `\n${ts}]\n}`;
      const formattedObjects = objects.join(',\n');
      return `${start}${formattedObjects}${end}`;
    }

    // 🧩 Step 2: Parse JSON safely
    function parseJsonSafely(jsonString) {
      try {
        return {
          ok: true,
          data: JSON.parse(jsonString),
          error: null
        };
      } catch (e) {
        return {
          ok: false,
          data: null,
          error: e.message
        };
      }
    }

    // 🧩 Step 3: Interpret JSON data
function quaternionToEuler(q) {
  const { X, Y, Z, W } = q;

  const x = Number(X);
  const y = Number(Y);
  const z = Number(Z);
  const w = Number(W);

  // Calcul en radians
  const sinr_cosp = 2 * (w * x + y * z);
  const cosr_cosp = 1 - 2 * (x * x + y * y);
  const roll = Math.atan2(sinr_cosp, cosr_cosp);

  const sinp = 2 * (w * y - z * x);
  let pitch;
  if (Math.abs(sinp) >= 1)
    pitch = Math.sign(sinp) * Math.PI / 2; // 90° clamp
  else
    pitch = Math.asin(sinp);

  const siny_cosp = 2 * (w * z + x * y);
  const cosy_cosp = 1 - 2 * (y * y + z * z);
  const yaw = Math.atan2(siny_cosp, cosy_cosp);

  // Conversion en degrés
  const toDeg = rad => (rad * 180 / Math.PI).toFixed(1);

  return {
    Roll: toDeg(roll),
    Pitch: toDeg(pitch),
    Yaw: toDeg(yaw)
  };
}

function detectValueType(val) {
  if (typeof val !== 'object' || val === null) return 'unknown';

  const keys = Object.keys(val).sort();

  if (keys.join() === 'X,Y,Z') return 'vector3';
  if (keys.join() === 'W,X,Y,Z') return 'quat';
  if (keys.join() === 'X,Y,Z,W') return 'quat';
  if (keys.join() === 'R,G,B') return 'color_rgb';
  if (keys.join() === 'A,B,G,R') return 'color_rgba';
  if (keys.join() === 'R,G,B,A') return 'color_rgba';

  return 'object';
}

function formatValueAsHtml(val) {
  const type = detectValueType(val);

  if (type === 'vector3') {
    return `<span style="color:#f55">X=${val.X}</span>, ` +  // Red
           `<span style="color:#5f5">Y=${val.Y}</span>, ` +  // Green
           `<span style="color:#55f">Z=${val.Z}</span>`;     // Blue
  }

  if (type === 'quat') {
    const euler = quaternionToEuler(val);

    return (
      `<span style="color:#ff5">W=${val.W ?? '?'}</span>, ` +
      `<span style="color:#f55">X=${val.X ?? '?'}</span>, ` +
      `<span style="color:#5f5">Y=${val.Y ?? '?'}</span>, ` +
      `<span style="color:#55f">Z=${val.Z ?? '?'}</span>` +
      ` <span style="color:#888">→</span> (` +
      `<span style="color:#f55">Roll=${euler.Roll}°</span>, ` +
      `<span style="color:#5f5">Pitch=${euler.Pitch}°</span>, ` +
      `<span style="color:#55f">Yaw=${euler.Yaw}°</span>)`
    );
  }

  if (type === 'color_rgb' || type === 'color_rgba') {
    return `<span style="color:#ff0">R=${val.R}</span>, ` +  // Red
           `<span style="color:#0f0">G=${val.G}</span>, ` +  // Green
           `<span style="color:#00f">B=${val.B}</span>` +     // Blue
           (val.A !== undefined ? `, <span style="color:#aaa">A=${val.A}</span>` : ''); // Yellow
  }

  if (typeof val === 'object') {
    return Object.entries(val).map(([k, v]) => `${k}=${v}`).join(', ');
  }

  return String(val);
}

function interpretJsonData(parsedJson) {
  const out = [];
  const objects = parsedJson?.objects ?? [];

  objects.forEach((obj, i) => {
    const keys = Object.keys(obj);
    const boxTitle = keys.includes("Class") ? `${obj.Class} (${i})` : `Object ${i}`;
    let content = '';

    if (obj.Class === "/Script/Engine.SplineComponent") {
      const curves = obj.SplineCurves ?? {};
      const posPoints = curves.Position?.Points ?? [];
      const rotPoints = curves.Rotation?.Points ?? [];
      const scalePoints = curves.Scale?.Points ?? [];

      const maxPoints = Math.max(posPoints.length, rotPoints.length, scalePoints.length);
      content += `Spline Component:\nPoints:\n`;

      for (let idx = 0; idx < maxPoints; idx++) {
        content += `[${idx}]\n`;

        const loc = posPoints[idx] ?? {};
        const rot = rotPoints[idx] ?? {};
        const scl = scalePoints[idx] ?? {};

        // --- Loc
        content += `  Loc:    InVal: ${loc.InVal ?? '-'}\n`;
        if (loc.OutVal) content += `          OutVal: ${formatValueAsHtml(loc.OutVal)}\n`;
        if (loc.ArriveTangent) content += `          ArriveTangent: ${formatValueAsHtml(loc.ArriveTangent)}\n`;
        if (loc.LeaveTangent) content += `          LeaveTangent: ${formatValueAsHtml(loc.LeaveTangent)}\n`;
        if (loc.InterpMode) content += `          InterpMode: ${loc.InterpMode}\n`;

        // --- Rot
        content += `  Rot:    InVal: ${rot.InVal ?? '-'}\n`;
        if (rot.OutVal) content += `          OutVal: ${formatValueAsHtml(rot.OutVal)}\n`;
        if (rot.ArriveTangent) content += `          ArriveTangent: ${formatValueAsHtml(rot.ArriveTangent)}\n`;
        if (rot.LeaveTangent) content += `          LeaveTangent: ${formatValueAsHtml(rot.LeaveTangent)}\n`;
        if (rot.InterpMode) content += `          InterpMode: ${rot.InterpMode}\n`;

        // --- Scale
        content += `  Scale:  InVal: ${scl.InVal ?? '-'}\n`;
        if (scl.OutVal) content += `          OutVal: ${formatValueAsHtml(scl.OutVal)}\n`;
        if (scl.ArriveTangent) content += `          ArriveTangent: ${formatValueAsHtml(scl.ArriveTangent)}\n`;
        if (scl.LeaveTangent) content += `          LeaveTangent: ${formatValueAsHtml(scl.LeaveTangent)}\n`;
        if (scl.InterpMode) content += `          InterpMode: ${scl.InterpMode}\n`;

        content += `\n`;
      }
    } else {
      content += Object.entries(obj)
        .map(([k, v]) => `${k}: ${JSON.stringify(v)}`)
        .join('\n');
    }

    out.push(`
<details>
  <summary><strong>${boxTitle}</strong></summary>
  <pre>${content}</pre>
</details>`);
  });

  return out.join('\n') || "(no objects found)";
}


    // 🧪 Main function triggered by the button
    function convert() {
      const input = document.getElementById("inputText").value;

      const jsonLike = preformatTextToJsonString(input);
      document.getElementById("outputRaw").textContent = jsonLike;

      const result = parseJsonSafely(jsonLike);
      if (!result.ok) {
        document.getElementById("outputParsed").textContent = "❌ JSON Error: " + result.error;
        document.getElementById("outputSummary").textContent = "";
        return;
      }

      document.getElementById("outputParsed").textContent = JSON.stringify(result.data, null, 2);
      document.getElementById("outputSummary").innerHTML = interpretJsonData(result.data);
    }
  </script>
</body>
</html>